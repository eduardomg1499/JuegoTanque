<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Guerra de Tanques Multijugador</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overscroll-behavior: none; /* Evita el rebote en móviles */
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 1000px;
            max-height: 700px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 12px;
            background-color: #2a2a2a;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background-color: #333;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            z-index: 10;
            border-radius: 10px;
            text-align: center;
            padding: 1rem;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
        }
        .hidden {
            opacity: 0;
            visibility: hidden;
        }
        .btn {
            background-color: #00ff88;
            color: #1a1a1a;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
        }
        input[type="text"] {
            background-color: #444;
            border: 2px solid #666;
            color: #f0f0f0;
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2rem;
            width: 180px;
            margin: 0.5rem;
        }
        #status-message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #00ff88;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 20;
            font-size: 1em;
            text-align: center;
            display: none;
            transition: opacity 0.5s;
        }
        /* Controles para Móvil */
        #d-pad {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none; /* Oculto por defecto */
            z-index: 5;
            user-select: none;
        }
        #fire-button {
            position: absolute;
            bottom: 40px;
            right: 40px;
            display: none; /* Oculto por defecto */
            z-index: 5;
            user-select: none;
        }
        .d-pad-btn, #fire-button button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
        }
        .d-pad-grid {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 10px;
        }
        #d-pad-up { grid-area: 1 / 2 / 2 / 3; }
        #d-pad-left { grid-area: 2 / 1 / 3 / 2; }
        #d-pad-right { grid-area: 2 / 3 / 3 / 4; }
        #d-pad-down { grid-area: 3 / 2 / 4 / 3; }

        @media (max-width: 768px) {
            #d-pad, #fire-button {
                display: block;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="status-message"></div>
        <canvas id="gameCanvas"></canvas>
        <div id="ui-overlay">
            <h1 class="text-4xl md:text-5xl font-bold mb-4 text-[#00ff88]">Guerra de Tanques</h1>
            <p class="text-lg md:text-xl mb-8">Destruye al tanque enemigo.</p>
            
            <div id="main-menu">
                <button id="create-game-btn" class="btn">Crear Partida</button>
                <div class="my-4 text-lg">o</div>
                <div class="flex flex-col md:flex-row items-center">
                    <input type="text" id="join-game-input" placeholder="Código de Partida">
                    <button id="join-game-btn" class="btn">Unirse a Partida</button>
                </div>
            </div>

            <div id="waiting-room" class="hidden text-center">
                <h2 class="text-2xl md:text-3xl mb-4">Esperando al oponente...</h2>
                <p class="mb-4">Comparte este código con tu amigo:</p>
                <div id="game-id-display" class="text-xl md:text-2xl font-bold bg-[#222] p-2 rounded-md border-dashed border-[#00ff88] cursor-pointer"></div>
                 <p class="mt-2 text-sm text-gray-400">(Haz clic en el código para copiar)</p>
            </div>
        </div>

        <!-- Controles Móviles -->
        <div id="d-pad">
            <div class="d-pad-grid">
                <button id="d-pad-up" class="d-pad-btn">▲</button>
                <button id="d-pad-left" class="d-pad-btn">◀</button>
                <button id="d-pad-right" class="d-pad-btn">▶</button>
                <button id="d-pad-down" class="d-pad-btn">▼</button>
            </div>
        </div>
        <div id="fire-button">
            <button>●</button>
        </div>
    </div>

    <script type="module">
        // --- IMPORTACIONES DE FIREBASE ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, onSnapshot, updateDoc, serverTimestamp, collection, addDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURACIÓN DE FIREBASE Y JUEGO ---
        const firebaseConfig = {
            apiKey: "AIzaSyDKxJUQWP0VM0aRYrFbgkrJ-pYMV7GGxTE",
            authDomain: "juego-de-tanques-2c64e.firebaseapp.com",
            projectId: "juego-de-tanques-2c64e",
            storageBucket: "juego-de-tanques-2c64e.appspot.com",
            messagingSenderId: "857564001327",
            appId: "1:857564001327:web:2bc65a51a3f0ae789b82da",
            measurementId: "G-CTVMR12X4Z"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- ESTADO DEL JUEGO ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiOverlay = document.getElementById('ui-overlay');
        const mainMenu = document.getElementById('main-menu');
        const waitingRoom = document.getElementById('waiting-room');
        const createGameBtn = document.getElementById('create-game-btn');
        const joinGameInput = document.getElementById('join-game-input');
        const joinGameBtn = document.getElementById('join-game-btn');
        const gameIdDisplay = document.getElementById('game-id-display');
        const statusMessage = document.getElementById('status-message');

        let gameId = null;
        let playerId = null;
        let playerNumber = null;
        let gameState = { players: {}, projectiles: [] };
        let gameUnsubscribe = null;
        let animationFrameId = null;
        const keys = {};

        // --- COORDINADAS VIRTUALES Y ESCALADO ---
        const VIRTUAL_WIDTH = 1000;
        const VIRTUAL_HEIGHT = 700;
        let scaleX = 1, scaleY = 1;

        const obstacles = [
            { x: 200, y: 150, width: 150, height: 30 },
            { x: 650, y: 500, width: 150, height: 30 },
            { x: 500, y: 300, width: 30, height: 150 },
            { x: 100, y: 400, width: 30, height: 200 },
            { x: 800, y: 100, width: 30, height: 200 },
        ];
        
        function showTemporaryMessage(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.backgroundColor = isError ? 'rgba(239, 68, 68, 0.9)' : 'rgba(34, 197, 94, 0.9)';
            statusMessage.style.display = 'block';
            statusMessage.style.opacity = '1';
            setTimeout(() => {
                statusMessage.style.opacity = '0';
                setTimeout(() => statusMessage.style.display = 'none', 500);
            }, 4500);
        }

        async function init() {
            try { await signInAnonymously(auth); } catch (error) {
                console.error("Error en la autenticación:", error);
                if (error.code === 'auth/configuration-not-found') {
                    showTemporaryMessage("Error: Ve a tu consola de Firebase > Authentication > Sign-in method y habilita la opción 'Anónimo'.", true);
                } else { showTemporaryMessage("Error de autenticación. Revisa la consola.", true); }
            }
            onAuthStateChanged(auth, (user) => { if (user) playerId = user.uid; });
        }

        createGameBtn.addEventListener('click', async () => {
            if (!playerId) return showTemporaryMessage("Aún no se ha autenticado. Intenta de nuevo.", true);
            playerNumber = 1;
            try {
                const gameCollectionRef = collection(db, "games");
                const newGameDoc = await addDoc(gameCollectionRef, {
                    status: 'waiting',
                    createdAt: serverTimestamp(),
                    players: { [playerId]: { number: 1, x: 100, y: 100, angle: 0, health: 100, isHost: true, id: playerId } },
                    projectiles: [],
                });
                gameId = newGameDoc.id;
                gameIdDisplay.textContent = gameId;
                mainMenu.classList.add('hidden');
                waitingRoom.classList.remove('hidden');
                listenToGameUpdates();
            } catch (error) {
                console.error("Error al crear partida:", error);
                showTemporaryMessage("Error al crear partida. Revisa las reglas de Firestore.", true);
            }
        });
        
        joinGameBtn.addEventListener('click', async () => {
            const idToJoin = joinGameInput.value.trim();
            if (!idToJoin || !playerId) return showTemporaryMessage("Introduce un código de partida.", true);
            gameId = idToJoin;
            const gameRef = doc(db, "games", gameId);
            try {
                const gameSnap = await getDoc(gameRef);
                if (gameSnap.exists()) {
                    const gameData = gameSnap.data();
                    if (Object.keys(gameData.players).length < 2) {
                        playerNumber = 2;
                        await updateDoc(gameRef, {
                            status: 'playing',
                            [`players.${playerId}`]: { number: 2, x: VIRTUAL_WIDTH - 100, y: VIRTUAL_HEIGHT - 100, angle: Math.PI, health: 100, isHost: false, id: playerId }
                        });
                        listenToGameUpdates();
                    } else showTemporaryMessage("La partida está llena.", true);
                } else showTemporaryMessage("No se encontró la partida.", true);
            } catch (error) {
                console.error("Error al unirse:", error);
                showTemporaryMessage("Error al unirse. Revisa el código y tu conexión.", true);
            }
        });

        gameIdDisplay.addEventListener('click', () => {
            const textToCopy = gameId;
            if (!textToCopy) return;
            const textArea = document.createElement("textarea");
            textArea.value = textToCopy;
            document.body.appendChild(textArea);
            textArea.select();
            try { document.execCommand('copy'); showTemporaryMessage('¡Código copiado!'); }
            catch (err) { showTemporaryMessage('No se pudo copiar.', true); }
            document.body.removeChild(textArea);
        });

        function listenToGameUpdates() {
            if (gameUnsubscribe) gameUnsubscribe();
            const gameRef = doc(db, "games", gameId);
            gameUnsubscribe = onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) return endGame("El oponente ha abandonado.");
                
                const remoteGameState = docSnap.data();
                if (remoteGameState) gameState = remoteGameState;
                
                if ((gameState.status === 'playing' || (gameState.status === 'waiting' && Object.keys(gameState.players).length === 2))) {
                    if (gameState.status === 'waiting') updateDoc(doc(db, "games", gameId), { status: 'playing' });
                    if (!animationFrameId) { resizeCanvas(); animationFrameId = requestAnimationFrame(gameLoop); }
                    uiOverlay.classList.add('hidden');
                } else if (gameState.status.includes('_wins')) {
                    const winnerNum = parseInt(gameState.status.charAt(1));
                    endGame(winnerNum === playerNumber ? "¡Has ganado!" : "¡Has perdido!");
                }
            });
        }
        
        class Tank {
            constructor(data) { this.data = data; }
            draw() {
                const { x, y, angle, health, number } = this.data;
                const width = 40, height = 50;
                const color = number === 1 ? '#4ade80' : '#f87171';
                const turretColor = number === 1 ? '#16a34a' : '#dc2626';
                ctx.save();
                ctx.translate(x * scaleX, y * scaleY);
                ctx.rotate(angle);
                // Cuerpo del tanque
                ctx.fillStyle = color;
                ctx.fillRect(-width/2 * scaleX, -height/2 * scaleY, width * scaleX, height * scaleY);
                // Torreta corregida para apuntar hacia arriba (dirección de movimiento)
                ctx.fillStyle = turretColor;
                ctx.fillRect(-5 * scaleX, -35 * scaleY, 10 * scaleX, 35 * scaleY);
                ctx.restore();
                
                // Barra de vida
                const healthBarWidth = 50;
                ctx.fillStyle = '#3f3f46';
                ctx.fillRect((x - healthBarWidth/2) * scaleX, (y - height/2 - 15) * scaleY, healthBarWidth * scaleX, 8 * scaleY);
                ctx.fillStyle = '#22c55e';
                ctx.fillRect((x - healthBarWidth/2) * scaleX, (y - height/2 - 15) * scaleY, (healthBarWidth * Math.max(0, health / 100)) * scaleX, 8 * scaleY);
            }
        }
        
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(0,0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#8f8f8f';
            obstacles.forEach(o => ctx.fillRect(o.x * scaleX, o.y * scaleY, o.width * scaleX, o.height * scaleY));

            if (gameState.players) for (const pId in gameState.players) new Tank(gameState.players[pId]).draw();

            if (gameState.projectiles) {
                const now = Date.now();
                ctx.fillStyle = '#fef08a';
                gameState.projectiles.forEach(p => {
                    const elapsedTime = (now - p.createdAt) / 1000.0;
                    const currentX = p.initialX + Math.sin(p.angle) * p.speed * elapsedTime;
                    const currentY = p.initialY - Math.cos(p.angle) * p.speed * elapsedTime;
                    ctx.beginPath();
                    ctx.arc(currentX * scaleX, currentY * scaleY, 5 * scaleX, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        function handleInput() {
            if (!gameState.players || !gameState.players[playerId]) return;
            const p = gameState.players[playerId];
            let { x, y, angle } = p;
            let needsUpdate = false;
            const speed = 4, rotationSpeed = 0.05;
            let newX = x, newY = y;

            if (keys['w'] || keys['ArrowUp']) { newY -= speed; needsUpdate = true; }
            if (keys['s'] || keys['ArrowDown']) { newY += speed * 0.7; needsUpdate = true; }
            
            // Transformar movimiento lateral según el ángulo actual
            const moveX = (keys['a'] || keys['ArrowLeft']) ? -speed : (keys['d'] || keys['ArrowRight']) ? speed : 0;
            if(moveX !== 0) {
                newX += moveX;
                needsUpdate = true;
            }

            // Rotación
            if (keys['a'] || keys['ArrowLeft']) { angle -= rotationSpeed; needsUpdate = true; }
            if (keys['d'] || keys['ArrowRight']) { angle += rotationSpeed; needsUpdate = true; }

            // Aplicar la rotación al movimiento
            const finalX = x + (newX-x)*Math.cos(angle) - (newY-y)*Math.sin(angle);
            const finalY = y + (newX-x)*Math.sin(angle) + (newY-y)*Math.cos(angle);


            const w = 40, h = 50;
            const playerRect = { x: finalX - w/2, y: finalY - h/2, width: w, height: h };
            let collision = playerRect.x < 0 || playerRect.x + w > VIRTUAL_WIDTH || playerRect.y < 0 || playerRect.y + h > VIRTUAL_HEIGHT;
            if (!collision) {
                for (const o of obstacles) {
                    if (playerRect.x < o.x + o.width && playerRect.x + w > o.x && playerRect.y < o.y + o.height && playerRect.y + h > o.y) {
                        collision = true; break;
                    }
                }
            }
            if (!collision) { p.x = finalX; p.y = finalY; }
            p.angle = angle;
            
            if (needsUpdate) {
                const gameRef = doc(db, "games", gameId);
                updateDoc(gameRef, { [`players.${playerId}.x`]: p.x, [`players.${playerId}.y`]: p.y, [`players.${playerId}.angle`]: p.angle });
            }
        }
        
        let lastShotTime = 0;
        function handleShooting() {
            if (keys[' '] && Date.now() - lastShotTime > 500) {
                lastShotTime = Date.now();
                if (!gameState.players || !gameState.players[playerId]) return;

                const p = gameState.players[playerId];
                const turretLength = 35;
                const newProjectile = {
                    id: `${playerId}-${Date.now()}`,
                    ownerId: playerId,
                    initialX: p.x - Math.sin(p.angle) * turretLength,
                    initialY: p.y - Math.cos(p.angle) * turretLength,
                    angle: p.angle,
                    speed: 500, // Pixeles virtuales por segundo
                    createdAt: Date.now()
                };
                
                const gameRef = doc(db, "games", gameId);
                updateDoc(gameRef, { projectiles: arrayUnion(newProjectile) });
            }
        }

        function updateGameStateOnHost() {
            if (!gameState || !gameState.players || !gameState.players[playerId] || !gameState.players[playerId].isHost) return;
            
            const now = Date.now();
            let players = JSON.parse(JSON.stringify(gameState.players));
            let stateChanged = false;
            const projectileLifetime = 3000;

            const updatedProjectiles = (gameState.projectiles || []).filter(p => {
                if (now - p.createdAt > projectileLifetime) {
                    stateChanged = true; return false;
                }
                const elapsedTime = (now - p.createdAt) / 1000.0;
                const currentX = p.initialX + Math.sin(p.angle) * p.speed * elapsedTime;
                const currentY = p.initialY - Math.cos(p.angle) * p.speed * elapsedTime;
                
                if (currentX < 0 || currentX > VIRTUAL_WIDTH || currentY < 0 || currentY > VIRTUAL_HEIGHT) { stateChanged = true; return false; }
                
                for (const o of obstacles) {
                    if (currentX > o.x && currentX < o.x + o.width && currentY > o.y && currentY < o.y + o.height) {
                        stateChanged = true; return false;
                    }
                }
                for (const pId in players) {
                    if (p.ownerId !== pId && players[pId].health > 0) {
                        const tank = players[pId];
                        if (Math.sqrt((currentX - tank.x)**2 + (currentY - tank.y)**2) < 30) {
                            players[pId].health -= 10;
                            stateChanged = true;
                            return false;
                        }
                    }
                }
                return true;
            });

            if (stateChanged) {
                 const updates = { projectiles: updatedProjectiles, players };
                 for (const pId in players) {
                     if (players[pId].health <= 0) {
                        players[pId].health = 0;
                        const winner = Object.values(players).find(pl => pl.id !== pId);
                        if (gameState.status === 'playing' && winner) {
                           updates.status = `p${winner.number}_wins`;
                           break;
                        }
                     }
                 }
                updateDoc(doc(db, "games", gameId), updates);
            }
        }
        
        function gameLoop() {
            if (!gameState || !gameState.players || gameState.status !== 'playing') {
                animationFrameId = requestAnimationFrame(gameLoop); return;
            }
            
            handleInput();
            handleShooting();
            updateGameStateOnHost();
            drawGame();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endGame(message) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (gameUnsubscribe) gameUnsubscribe();
            animationFrameId = null; gameUnsubscribe = null;
            showTemporaryMessage(message, false);
            setTimeout(() => {
                uiOverlay.classList.remove('hidden');
                mainMenu.classList.remove('hidden');
                waitingRoom.classList.add('hidden');
            }, 5000);
        }
        
        function setupMobileControls() {
            const keyMap = { 'd-pad-up': 'w', 'd-pad-down': 's', 'd-pad-left': 'a', 'd-pad-right': 'd' };
            Object.keys(keyMap).forEach(id => {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[keyMap[id]] = true; }, { passive: false });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[keyMap[id]] = false; }, { passive: false });
            });
            const fireBtn = document.querySelector('#fire-button button');
            fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[' '] = true; }, { passive: false });
            fireBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys[' '] = false; }, { passive: false });
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            scaleX = canvas.width / VIRTUAL_WIDTH;
            scaleY = canvas.height / VIRTUAL_HEIGHT;
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        
        init();
        resizeCanvas();
        setupMobileControls();

    </script>
</body>
</html>
