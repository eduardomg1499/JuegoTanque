<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guerra de Tanques Multijugador</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        #game-container {
            position: relative;
            width: 90vw;
            height: 90vh;
            max-width: 1000px;
            max-height: 700px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 12px;
            background-color: #2a2a2a;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background-color: #333;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            z-index: 10;
            border-radius: 10px;
            text-align: center;
            padding: 2rem;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
        }
        .hidden {
            opacity: 0;
            visibility: hidden;
        }
        .btn {
            background-color: #00ff88;
            color: #1a1a1a;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
        }
        input[type="text"] {
            background-color: #444;
            border: 2px solid #666;
            color: #f0f0f0;
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2rem;
            width: 200px;
            margin: 0 1rem;
        }
        #game-id-display {
            background-color: #222;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: 1px dashed #00ff88;
            cursor: pointer;
            margin-top: 1rem;
        }
        #status-message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            color: #00ff88;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 5;
            font-size: 1.2em;
            display: none; /* Initially hidden */
        }
        .health-bar {
            position: absolute;
            height: 5px;
            background-color: #00ff88;
            border: 1px solid #000;
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="status-message"></div>
        <canvas id="gameCanvas"></canvas>
        <div id="ui-overlay">
            <h1 class="text-5xl font-bold mb-4 text-[#00ff88]">Guerra de Tanques</h1>
            <p class="text-xl mb-8">Destruye al tanque enemigo.</p>
            
            <div id="main-menu">
                <button id="create-game-btn" class="btn">Crear Partida</button>
                <div class="my-4 text-lg">o</div>
                <div class="flex items-center">
                    <input type="text" id="join-game-input" placeholder="Código de Partida">
                    <button id="join-game-btn" class="btn">Unirse a Partida</button>
                </div>
            </div>

            <div id="waiting-room" class="hidden">
                <h2 class="text-3xl mb-4">Esperando al oponente...</h2>
                <p class="mb-4">Comparte este código con tu amigo:</p>
                <div id="game-id-display" class="text-2xl font-bold"></div>
                 <p class="mt-2 text-sm text-gray-400">(Haz clic en el código para copiar)</p>
            </div>
        </div>
    </div>

    <script type="module">
        // --- IMPORTACIONES DE FIREBASE ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, serverTimestamp, collection, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURACIÓN DE FIREBASE Y JUEGO ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_API_KEY", authDomain: "...", projectId: "..." };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-tank-game';

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- ELEMENTOS DEL DOM ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiOverlay = document.getElementById('ui-overlay');
        const mainMenu = document.getElementById('main-menu');
        const waitingRoom = document.getElementById('waiting-room');
        const createGameBtn = document.getElementById('create-game-btn');
        const joinGameInput = document.getElementById('join-game-input');
        const joinGameBtn = document.getElementById('join-game-btn');
        const gameIdDisplay = document.getElementById('game-id-display');
        const statusMessage = document.getElementById('status-message');

        // --- ESTADO DEL JUEGO ---
        let gameId = null;
        let playerId = null;
        let playerNumber = null; // 1 o 2
        let gameState = {};
        let gameUnsubscribe = null;
        let animationFrameId = null;
        const keys = {};

        // --- OBSTÁCULOS (predefinidos) ---
        const obstacles = [
            { x: 200, y: 150, width: 150, height: 30 },
            { x: 600, y: 450, width: 150, height: 30 },
            { x: 400, y: 300, width: 30, height: 150 },
            { x: 100, y: 400, width: 30, height: 150 },
            { x: 700, y: 100, width: 30, height: 150 },
        ];
        
        // --- FUNCIÓN DE UTILIDAD PARA MENSAJES ---
        function showTemporaryMessage(message, isError = false) {
            const messageContainer = document.getElementById('ui-overlay');
            const messageElement = document.createElement('div');
            messageElement.textContent = message;
            messageElement.style.position = 'absolute';
            messageElement.style.bottom = '20px';
            messageElement.style.left = '50%';
            messageElement.style.transform = 'translateX(-50%)';
            messageElement.style.padding = '10px 20px';
            messageElement.style.borderRadius = '8px';
            messageElement.style.color = 'white';
            messageElement.style.backgroundColor = isError ? 'rgba(239, 68, 68, 0.9)' : 'rgba(34, 197, 94, 0.9)'; // rojo o verde
            messageElement.style.zIndex = '100';
            messageElement.style.transition = 'opacity 0.5s';
            messageElement.style.textAlign = 'center';

            messageContainer.appendChild(messageElement);

            setTimeout(() => {
                messageElement.style.opacity = '0';
                setTimeout(() => {
                    if (messageContainer.contains(messageElement)) {
                        messageContainer.removeChild(messageElement);
                    }
                }, 500);
            }, 2500);
        }

        // --- AUTENTICACIÓN Y LÓGICA DE PARTIDA ---
        async function init() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Error en la autenticación:", error);
                statusMessage.textContent = "Error de autenticación.";
                statusMessage.style.display = 'block';
            }
            
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    playerId = user.uid;
                    console.log("Autenticado como:", playerId);
                } else {
                    console.log("Usuario no autenticado.");
                }
            });
        }

        createGameBtn.addEventListener('click', async () => {
            if (!playerId) return;
            playerNumber = 1;
            const gameRef = collection(db, "artifacts", appId, "public", "data", "games");
            const newGameDoc = await addDoc(gameRef, {
                status: 'waiting',
                createdAt: serverTimestamp(),
                players: {
                    [playerId]: {
                        number: 1,
                        x: 100, y: 100, angle: 0, health: 100, 
                        isHost: true, id: playerId
                    }
                },
                projectiles: [],
            });
            
            gameId = newGameDoc.id;
            gameIdDisplay.textContent = gameId;
            mainMenu.classList.add('hidden');
            waitingRoom.classList.remove('hidden');
            listenToGameUpdates();
        });

        joinGameBtn.addEventListener('click', async () => {
            const idToJoin = joinGameInput.value.trim();
            if (!idToJoin || !playerId) {
                showTemporaryMessage("Por favor, introduce un código de partida válido.", true);
                return;
            };
            
            gameId = idToJoin;
            const gameRef = doc(db, "artifacts", appId, "public", "data", "games", gameId);
            const gameSnap = await getDoc(gameRef);

            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                if (Object.keys(gameData.players).length < 2) {
                    playerNumber = 2;
                    const opponentId = Object.keys(gameData.players)[0];

                    await updateDoc(gameRef, {
                        status: 'playing',
                        [`players.${playerId}`]: {
                            number: 2,
                            x: canvas.width - 100, y: canvas.height - 100, angle: Math.PI, health: 100,
                            isHost: false, id: playerId
                        }
                    });
                    listenToGameUpdates();
                } else {
                    showTemporaryMessage("La partida está llena.", true);
                }
            } else {
                showTemporaryMessage("No se encontró la partida.", true);
            }
        });

        gameIdDisplay.addEventListener('click', () => {
            const textToCopy = gameId;
            if (!textToCopy) return;

            const textArea = document.createElement("textarea");
            textArea.value = textToCopy;
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showTemporaryMessage('¡Código de partida copiado!');
                } else {
                    showTemporaryMessage('No se pudo copiar el código.', true);
                }
            } catch (err) {
                console.error('Fallback: No se pudo copiar', err);
                showTemporaryMessage('Error al intentar copiar.', true);
            }

            document.body.removeChild(textArea);
        });

        function listenToGameUpdates() {
            if (gameUnsubscribe) gameUnsubscribe();
            
            const gameRef = doc(db, "artifacts", appId, "public", "data", "games", gameId);
            gameUnsubscribe = onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) {
                    endGame("El oponente ha abandonado la partida.");
                    return;
                }

                gameState = docSnap.data();

                if (gameState.status === 'waiting' && playerNumber === 1) {
                    // Sigue esperando
                } else if (gameState.status === 'playing' || gameState.status === 'waiting') {
                     if (Object.keys(gameState.players).length === 2) {
                        gameState.status = 'playing';
                        uiOverlay.classList.add('hidden');
                        if (!animationFrameId) {
                            resizeCanvas();
                            gameLoop();
                        }
                     }
                } else if (gameState.status.includes('_wins')) {
                    const winnerNum = parseInt(gameState.status.charAt(1));
                    const message = winnerNum === playerNumber ? "¡Has ganado!" : "¡Has perdido!";
                    endGame(message);
                }
            });
        }
        
        // --- LÓGICA DEL JUEGO ---

        class Tank {
            constructor(data, id) {
                this.id = id;
                this.x = data.x;
                this.y = data.y;
                this.angle = data.angle;
                this.health = data.health;
                this.number = data.number;
                this.width = 40;
                this.height = 50;
                this.color = this.number === 1 ? '#4ade80' : '#f87171';
                this.turretColor = this.number === 1 ? '#16a34a' : '#dc2626';
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Cuerpo del tanque
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Torreta
                ctx.fillStyle = this.turretColor;
                ctx.fillRect(-5, -7, 10, 40);

                ctx.restore();
                
                // Barra de vida
                const healthBarWidth = 50;
                const healthPercentage = this.health / 100;
                ctx.fillStyle = '#dc2626';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.height / 2 - 15, healthBarWidth, 8);
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.height / 2 - 15, healthBarWidth * healthPercentage, 8);
            }
        }
        
        function drawProjectiles() {
            if (!gameState.projectiles) return;
            ctx.fillStyle = '#fef08a';
            gameState.projectiles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawObstacles() {
            ctx.fillStyle = '#8a8a8a';
            obstacles.forEach(o => {
                ctx.fillRect(o.x, o.y, o.width, o.height);
            });
        }

        function handleInput() {
            if (!gameState.players || !gameState.players[playerId]) return;

            let playerState = { ...gameState.players[playerId] };
            let needsUpdate = false;
            const speed = 2.5;
            const rotationSpeed = 0.04;

            let newX = playerState.x;
            let newY = playerState.y;

            if (keys['w'] || keys['ArrowUp']) {
                newX += Math.sin(playerState.angle) * speed;
                newY -= Math.cos(playerState.angle) * speed;
                needsUpdate = true;
            }
            if (keys['s'] || keys['ArrowDown']) {
                newX -= Math.sin(playerState.angle) * (speed * 0.7);
                newY += Math.cos(playerState.angle) * (speed * 0.7);
                needsUpdate = true;
            }
            if (keys['a'] || keys['ArrowLeft']) {
                playerState.angle -= rotationSpeed;
                needsUpdate = true;
            }
            if (keys['d'] || keys['ArrowRight']) {
                playerState.angle += rotationSpeed;
                needsUpdate = true;
            }

            // Detección de colisiones simple
            const playerRect = { x: newX - 20, y: newY - 25, width: 40, height: 50 };
            let collision = false;
            // Colisión con bordes
            if (playerRect.x < 0 || playerRect.x + playerRect.width > canvas.width || playerRect.y < 0 || playerRect.y + playerRect.height > canvas.height) {
                collision = true;
            }
            // Colisión con obstáculos
            for (const o of obstacles) {
                if (playerRect.x < o.x + o.width && playerRect.x + playerRect.width > o.x &&
                    playerRect.y < o.y + o.height && playerRect.y + playerRect.height > o.y) {
                    collision = true;
                    break;
                }
            }

            if (!collision) {
                playerState.x = newX;
                playerState.y = newY;
            }

            if (needsUpdate) {
                const gameRef = doc(db, "artifacts", appId, "public", "data", "games", gameId);
                updateDoc(gameRef, {
                    [`players.${playerId}.x`]: playerState.x,
                    [`players.${playerId}.y`]: playerState.y,
                    [`players.${playerId}.angle`]: playerState.angle,
                });
            }
        }
        
        let lastShotTime = 0;
        function handleShooting() {
            if(keys[' ']) { // Barra espaciadora
                const now = Date.now();
                if (now - lastShotTime > 500) { // Cooldown de 500ms
                    lastShotTime = now;
                    const playerState = gameState.players[playerId];
                    const newProjectile = {
                        ownerId: playerId,
                        x: playerState.x + Math.sin(playerState.angle) * 40,
                        y: playerState.y - Math.cos(playerState.angle) * 40,
                        angle: playerState.angle,
                        speed: 6,
                    };
                    
                    const updatedProjectiles = [...(gameState.projectiles || []), newProjectile];
                    const gameRef = doc(db, "artifacts", appId, "public", "data", "games", gameId);
                    updateDoc(gameRef, { projectiles: updatedProjectiles });
                }
            }
        }

        // Esta función se ejecuta solo en el host para evitar cálculos duplicados
        function updateGameStateOnHost() {
            if (!gameState || !gameState.players[playerId] || !gameState.players[playerId].isHost) {
                 return;
            }
            
            let newProjectiles = [...(gameState.projectiles || [])];
            let players = { ...gameState.players };
            let stateChanged = false;

            // Mover proyectiles
            newProjectiles = newProjectiles.map(p => ({
                ...p,
                x: p.x + Math.sin(p.angle) * p.speed,
                y: p.y - Math.cos(p.angle) * p.speed,
            })).filter(p => p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height);

            // Colisión proyectil-obstáculo
             newProjectiles = newProjectiles.filter(p => {
                for (const o of obstacles) {
                    if (p.x > o.x && p.x < o.x + o.width && p.y > o.y && p.y < o.y + o.height) {
                        return false; // Eliminar proyectil
                    }
                }
                return true;
            });

            // Colisión proyectil-tanque
            const originalProjectileCount = newProjectiles.length;
            newProjectiles = newProjectiles.filter(p => {
                for (const pId in players) {
                    if (p.ownerId !== pId) {
                        const tank = players[pId];
                        const distance = Math.sqrt((p.x - tank.x)**2 + (p.y - tank.y)**2);
                        if (distance < 25) { // Radio de colisión del tanque
                            players[pId].health -= 10;
                            stateChanged = true;
                            return false; // Eliminar proyectil
                        }
                    }
                }
                return true;
            });
            
            if (newProjectiles.length !== (gameState.projectiles || []).length || stateChanged) {
                 const updates = { projectiles: newProjectiles, players: players };

                 // Verificar condición de victoria
                 for (const pId in players) {
                     if (players[pId].health <= 0) {
                        const winnerId = Object.keys(players).find(id => id !== pId);
                        const winner = players[winnerId];
                        updates.status = `p${winner.number}_wins`;
                     }
                 }
                const gameRef = doc(db, "artifacts", appId, "public", "data", "games", gameId);
                updateDoc(gameRef, updates);
            }
        }
        
        function gameLoop() {
            if (gameState.status !== 'playing') {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Fondo
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(0,0, canvas.width, canvas.height);
            
            drawObstacles();

            for (const pId in gameState.players) {
                const tank = new Tank(gameState.players[pId], pId);
                tank.draw();
            }

            drawProjectiles();

            handleInput();
            handleShooting();
            updateGameStateOnHost(); // Solo el host actualiza el estado global

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endGame(message) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null;
            }

            statusMessage.textContent = message;
            statusMessage.style.display = 'block';

            setTimeout(() => {
                // Reiniciar para una nueva partida
                uiOverlay.classList.remove('hidden');
                mainMenu.classList.remove('hidden');
                waitingRoom.classList.add('hidden');
                statusMessage.style.display = 'none';
                joinGameInput.value = '';
                gameId = null;
                playerNumber = null;
                gameState = {};
            }, 5000);
        }

        // --- MANEJO DE VENTANA Y TECLADO ---
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        
        // --- INICIO ---
        init();
        resizeCanvas();

    </script>
</body>
</html>